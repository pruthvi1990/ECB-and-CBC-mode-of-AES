/*######		ECB and CBC Implementation of AES								#########
########		University of Arizona, ECE 509, Cyber Security and Practices    #########
########		Authors: Pruthvi and Rachana Raj Sunku							#########
*/
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <time.h>

#define num_rows 4
#define num_cols 4
#define BILLION 1000000000L
#define num_rounds 10

uint8_t bit_shift(uint8_t x);
static uint8_t RoundKey[176]; //buffer used for key expansion; 44*4 bytes used in key expansion
typedef uint8_t state_next[4][4]; //buffer type to hold the intermediate output
static state_next* state; 
uint8_t *Key_ptr;
uint8_t *Init_vector;

static const uint8_t sbox[256] =   {
  //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };

static const uint8_t Rcon[255] = {
  0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
  0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 
  0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 
  0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
  0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 
  0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 
  0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 
  0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 
  0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 
  0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
  0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 
  0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 
  0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 
  0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 
  0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 
  0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb  };

  static const uint8_t rsbox[256] =
{ 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };


void Copy_text(uint8_t *in, uint8_t *out){
	
	int i;
	for(i=0; i<16; i++)
		out[i]=in[i];
}
		
void KeyExpansion(uint8_t *Key_ptr){

	uint8_t temp[4];
	int i=0,j=0;

	for (i=0;i<num_rows;i++){
		RoundKey[i*4+0]=Key_ptr[i*4+0];
		RoundKey[i*4+1]=Key_ptr[i*4+1];
		RoundKey[i*4+2]=Key_ptr[i*4+2];
		RoundKey[i*4+3]=Key_ptr[i*4+3];
	}

	int key_itr;
	key_itr =((num_rounds + 1 ) * num_rows);
        
	for (; i<key_itr;i++){
		for (j=0; j<num_cols;j++){
			temp[j]=RoundKey[(i-1)*4+j];
		}//end for
			
		if (i%4==0){

		uint8_t temp_byte;
		temp_byte=temp[0];
		temp[0]=temp[1];
		temp[1]=temp[2];
		temp[2]=temp[3];
		temp[3]=temp_byte;        				

		temp[0]=sbox[temp[0]];
		temp[1]=sbox[temp[1]];
		temp[2]=sbox[temp[2]];
		temp[3]=sbox[temp[3]];

		
		temp[0]= temp[0]^Rcon[(i/num_rows)];
		}//end if 
		
		//perform xor for roundkey(i-1) with roundkey(i-4)				

		RoundKey[i*4+0]=RoundKey[(i-4)*4+0]^temp[0];
		RoundKey[i*4+1]=RoundKey[(i-4)*4+1]^temp[1];
		RoundKey[i*4+2]=RoundKey[(i-4)*4+2]^temp[2];
		RoundKey[i*4+3]=RoundKey[(i-4)*4+3]^temp[3];

		}//end for

}//end KeyExpansion function

void AddRoundKey(int round)
{
	int i=0,j=0;

	for(i=0;i<4;i++)
	{
		for(j=0;j<4;j++)
		{
		(*state)[i][j]= (*state)[i][j] ^ RoundKey[round*num_rows*4 + i*num_rows +j];
		}
	}

}

void Subbytes(void)
{
	int i=0,j=0;

        for(i=0;i<4;i++)
        {
                for(j=0;j<4;j++)
                {
                        (*state)[i][j]= sbox[(*state)[i][j]];
                }
        }
	

}

void ShiftRows(void)
{
	
	int i=0,j=0;
	//Shift row 1 by 1 byte to the left
	uint8_t temp1= (*state)[0][1];
	(*state)[0][1]=(*state)[1][1];
	(*state)[1][1]=(*state)[2][1];
	(*state)[2][1]=(*state)[3][1];
	(*state)[3][1]=temp1;

	//Shift row 2 by 2 bytes to the left
	uint8_t temp2= (*state)[0][2];
	uint8_t temp3= (*state)[1][2];
	(*state)[0][2]=(*state)[2][2];
        (*state)[1][2]=(*state)[3][2];
        (*state)[2][2]=temp2;
        (*state)[3][2]=temp3;

	//Shift row 3 by 3 bytes to the left
	uint8_t temp4= (*state)[0][3];
        uint8_t temp5= (*state)[1][3];
        uint8_t temp6= (*state)[2][3];
	(*state)[0][3]=(*state)[3][3];
        (*state)[1][3]=temp4;
        (*state)[2][3]=temp5;
        (*state)[3][3]=temp6;

}

/*
Multiply each column of the output buffer with the matrix below to perform Mix Columns 
	02 01 01 03
	03 02 01 01 
	01 03 02 01 
	01 01 03 02

Reference: http://crypto.stackexchange.com/questions/2402/how-to-solve-mixcolumns
*/
uint8_t bit_shift(uint8_t x)
{
	return ((x<<1) ^ (((x>>7) & 1) * 0x1b));
}

void MixColums(void)
{
	uint8_t res1=0,res2=0, res3=0;
	int i=0,j=0;

	for(i=0;i<4;i++)
	{
		res1=(*state)[i][0];
		res2 = (*state)[i][0] ^ (*state)[i][1] ^ (*state)[i][2] ^ (*state)[i][3];

		res3= (*state)[i][0] ^ (*state)[i][1];
		res3= bit_shift(res3);
		(*state)[i][0]= (*state)[i][0] ^ res2 ^ res3;

		res3= (*state)[i][1] ^ (*state)[i][2];
                res3= bit_shift(res3);
                (*state)[i][1]= (*state)[i][1] ^ res2 ^ res3;

		res3= (*state)[i][2] ^ (*state)[i][3];
                res3= bit_shift(res3);
                (*state)[i][2]= (*state)[i][2] ^ res2 ^ res3;

		res3= (*state)[i][3] ^ res1 ;
                res3= bit_shift(res3);
                (*state)[i][3]= (*state)[i][3] ^ res2 ^ res3;
	}

}

/*function to cipher the text block */
static void cipher(void)
{
	int round=0;
	AddRoundKey(0);

	for(round=1;round<num_rounds;++round)
	{
		Subbytes();
		ShiftRows();
		MixColums();
		AddRoundKey(round);
	}

	Subbytes();
	ShiftRows();
	AddRoundKey(num_rounds);
}

void Shiftrows_decipher(void){
	
	//Shift 1st column elements; 1 element to right 
	uint8_t temp;
	temp = (*state)[3][1];
	(*state)[3][1] = (*state)[2][1];
	(*state)[2][1] = (*state)[1][1];
	(*state)[1][1] = (*state)[0][1];
	(*state)[0][1] = temp;
	
	//Shift 2nd column elements; 2 element to right
	uint8_t temp2= (*state)[3][2];
	uint8_t temp3= (*state)[2][2];
	(*state)[3][2]=(*state)[1][2];
        (*state)[2][2]=(*state)[0][2];
        (*state)[1][2]=temp2;
        (*state)[0][2]=temp3;
		
	//Shift 3rd column elements; 3 elements to right 
	 temp=(*state)[0][3];
	  (*state)[0][3]=(*state)[1][3];
	  (*state)[1][3]=(*state)[2][3];
	  (*state)[2][3]=(*state)[3][3];
	  (*state)[3][3]=temp;
}

void Subbytes_decipher(void){
	
	int i=0,j=0;
	for (i=0; i<num_rows; i++){
		for (j=0;j<num_cols; j++){
			
			(*state)[i][j] = rsbox[(*state)[i][j]];
		}
	}
	
	
}

/* 
Multiplication function which implements the following below for Inverse MixColumns
		
		0E 0B 0D 09
		09 0E 0B 0D
		0D 09 0E 0B
		0B 0D 09 0E
		x×9 =(((x×2)×2)×2)+x
		x×11=((((x×2)×2)+x)×2)+x
		x×13=((((x×2)+x)×2)×2)+x
		x×14=((((x×2)+x)×2)+x)×2

Reference: http://crypto.stackexchange.com/questions/2569/how-does-one-implement-the-inverse-of-aes-mixcolumns
*/

static uint8_t Mul(uint8_t x, uint8_t y)
{
  return (((y & 1) * x) ^
       ((y>>1 & 1) * bit_shift(x)) ^
       ((y>>2 & 1) * bit_shift(bit_shift(x))) ^
       ((y>>3 & 1) * bit_shift(bit_shift(bit_shift(x)))) ^
       ((y>>4 & 1) * bit_shift(bit_shift(bit_shift(bit_shift(x))))));
}

void MixColums_decipher(void){
	
	int i;
	int w,x,y,z;
	
	for (i=0; i<num_rows; i++){
	
	w= (*state)[i][0];
	x= (*state)[i][1];
	y= (*state)[i][2];
	z= (*state)[i][3];
	
	//find the resultant column after Inverse Mix columns
	
	(*state)[i][0]=Mul(w,0x0e) ^ Mul(x,0x0b) ^ Mul(y,0x0d)^ Mul(z,0x09);
	(*state)[i][1]=Mul(w,0x09) ^ Mul(x,0x0e) ^ Mul(y,0x0b)^ Mul(z,0x0d);
	(*state)[i][2]=Mul(w,0x0d) ^ Mul(x,0x09) ^ Mul(y,0x0e)^ Mul(z,0x0b);
	(*state)[i][3]=Mul(w,0x0b) ^ Mul(x,0x0d) ^ Mul(y,0x09)^ Mul(z,0x0e);
	
	}
	
	
}
static void decipher(void){

	int round =10;
	AddRoundKey(num_rounds);
	
	for (round=num_rounds-1; round>0; --round){
		Shiftrows_decipher();
		Subbytes_decipher();
		AddRoundKey(round);
		MixColums_decipher();
	}

	Shiftrows_decipher();
	Subbytes_decipher();
	AddRoundKey(0);

}

void print_op(){
uint8_t i,j;
         printf("### state matrix #####\n\n");
                for (i=0; i<4; i++){
                        for (j=0;j<4;j++){
                        printf("%x\t",(*state)[i][j]);
                        }
                        printf("\n");
                }
}

/*Encryption driver function */
static void AES_128bit_encryption(uint8_t *input ,uint8_t *output,uint8_t *key){

		uint64_t diff;
		struct timespec start, end;
		clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &start);	/* mark start time */
		
		int i;
		Copy_text(input, output);
		state = (state_next*)output;
		Key_ptr=key;
		KeyExpansion(Key_ptr);		
		cipher();
		
		sleep(1);
		clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &end);		/* mark the end time */

		diff = BILLION * (end.tv_sec - start.tv_sec) + end.tv_nsec - start.tv_nsec;
		printf("elapsed process CPU time for Encryption = %llu nanoseconds\n", (long long unsigned int) diff);
}
	

/*Decryption driver function */
static void AES_128bit_decrytption(uint8_t *input ,uint8_t *output,uint8_t *key ){

	uint64_t diff;
	struct timespec start, end;
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &start);	/* mark start time */
	
	Copy_text(input,output);
	state = (state_next*)output; //Output buffer to copy the contents in to RAM and work on it
	Key_ptr=key;
	KeyExpansion(Key_ptr);
	decipher();
	
	sleep(1);
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &end);		/* mark the end time */

	diff = BILLION * (end.tv_sec - start.tv_sec) + end.tv_nsec - start.tv_nsec;
	printf("elapsed process CPU time for Decryption = %llu nanoseconds\n", (long long unsigned int) diff);
}

void xor_init_vec(uint8_t *output){
	
	uint8_t i,j;
	for (i=0; i<16; i++){
			output[i] ^= Init_vector[i];
	}
}

static void AES_128bit_encryption_CBC(uint8_t *input, uint8_t *output,uint8_t *key,uint32_t len,uint8_t *init_vector)
{
	uint64_t diff;
	struct timespec start, end;
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &start);	/* mark start time */
	
	intptr_t i;
	int j;
	uint8_t remaining_len = len % 16;
	uint8_t len_q = len/16;
	
	Key_ptr = key;
	KeyExpansion(Key_ptr);
	Init_vector = (uint8_t*)init_vector;
	Copy_text(input,output);
    state = (state_next*)output;

	for(i=0;i<len;i+=16)
	{
		xor_init_vec(input);
		Copy_text(input,output);
		state = (state_next*)output;
		cipher();
		Init_vector = output;
		input +=16;
		output +=16;
	}

	if(remaining_len)
	{
		Copy_text(input,output);
		memset(output+remaining_len,0,16-remaining_len);
		state = (state_next*)output;
		cipher();
	}
	
	sleep(1);
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &end);		/* mark the end time */

	diff = BILLION * (end.tv_sec - start.tv_sec) + end.tv_nsec - start.tv_nsec;
	printf("elapsed process CPU time for Encryption = %llu nanoseconds\n", (long long unsigned int) diff);
	
}	

static void AES_128bit_decryption_CBC(uint8_t *input ,uint8_t *output,uint8_t *key, uint8_t length, uint8_t *init_vec){
	
	uint64_t diff;
	struct timespec start, end;
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &start);	/* mark start time */

	Copy_text(input,output);
    state = (state_next*)output;
	uint8_t i;
	Key_ptr = key;	
	KeyExpansion(Key_ptr);
	Init_vector = init_vec;
	int extra_chunk = length%16;
	int chunk_size = length/16;
	
	for (i=0;i<chunk_size;i++){
		Copy_text(input,output);
		state = (state_next*)output;
		decipher();
		xor_init_vec(output);
		Init_vector = input;
		input+=16;				
		output+=16;
	}
	
	if (extra_chunk){
		Copy_text(input,output);
		memset(output+extra_chunk, 0, 16-extra_chunk);
		state = (state_next*)output;
		decipher();
	}
	
	sleep(1);
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &end);		/* mark the end time */

	diff = BILLION * (end.tv_sec - start.tv_sec) + end.tv_nsec - start.tv_nsec;
	printf("elapsed process CPU time for Decryption = %llu nanoseconds\n", (long long unsigned int) diff);
	
}
